#version 150
precision highp float;

uniform sampler2D receiver_positionmap;
uniform sampler2D refractive_normals;
uniform sampler2D refractive_positionmap;

uniform mat4 mLightProjectionMatrix;
uniform mat4 mModelViewProjection;
uniform vec3 vPrimaryLight;
uniform float fDispersion;
uniform vec4 vMask;

in vec2 Vertex;
out vec4 vColor;

#define NUM_ITERATIONS 3

inline vec3 sampleRecPos(vec2 vTexCoord) { return texture(receiver_positionmap,   vTexCoord).xyz; }
inline vec3 sampleRefPos(vec2 vTexCoord) { return texture(refractive_positionmap, vTexCoord).xyz; }
inline vec3 sampleRefNrm(vec2 vTexCoord) { return texture(refractive_normals,     vTexCoord).xyz; }

inline vec3 project(vec3 position)
{
 vec4 vProjected = mLightProjectionMatrix * vec4(position, 1.0);
 return sampleRecPos(vProjected.xy / vProjected.w);
}

vec3 estimateIntersection(vec3 v, vec3 r)
{
 vec3 p = v + r;

 for (int i = 0; i < NUM_ITERATIONS; ++i)
  p = v + r * distance( v, project(p) );

 return project(p);
}

void main()
{
 vec3 vRecPos = sampleRecPos(Vertex);
 vec3 vRefPos = sampleRefPos(Vertex);
 vec3 vRefNrm = sampleRefNrm(Vertex);
 
 vec3 vLight = normalize(vRefPos - vPrimaryLight);

 vRefNrm = refract( vLight, vRefNrm, 1.0 / 1.3333 + 0.25 * fDispersion );

// vRefNrm = reflect( vLight, vRefNrm );

 vColor = vMask;

 if ( length(vRefPos) == 0.0)
 {
  gl_Position = vec4(-1000.0);
  return;
 }

 vec3 vVertex = estimateIntersection( vRefPos.xyz, vRefNrm );
 gl_Position = mModelViewProjection * vec4(vVertex.xyz, 1.0);
}
